<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Converter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Fira+Mono&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Simple focus style for better accessibility */
        input:focus {
            box-shadow: 0 0 0 2px #60a5fa; /* blue-400 */
        }
        /* Use monospace for all converter fields */
        input {
            font-family: 'Fira Mono', 'Consolas', 'Menlo', 'Monaco', monospace;
        }
        #binary-bits * {
             font-family: 'Fira Mono', 'Consolas', 'Menlo', 'Monaco', monospace;
        }
        /* Style for date/time pickers */
        input[type="date"], input[type="time"] {
            color-scheme: dark;
        }
        /* Style for color picker */
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 0.5rem;
        }
    </style>
</head>
<body class="bg-gray-900 flex items-center justify-center min-h-screen py-8">

    <div class="bg-gray-800 p-8 rounded-2xl shadow-2xl w-full max-w-2xl mx-4">
        
        <h1 class="text-3xl font-bold text-center text-white mb-2">Data Converter</h1>
        <p class="text-center text-gray-400 mb-8">Convert between Hexadecimal, Decimal, Binary, Float, and more.</p>

        <div class="grid grid-cols-1 gap-6">
            <!-- Controls -->
            <div class="flex items-center gap-6 mb-2">
                <div class="flex items-center">
                    <input id="signed" type="checkbox" class="mr-2 accent-blue-500 w-5 h-5">
                    <label for="signed" class="text-gray-300 text-sm font-medium select-none cursor-pointer">Signed</label>
                </div>
                <div class="flex items-center gap-4 flex-wrap">
                    <label class="text-gray-300 text-sm font-medium">Size:</label>
                    <label class="flex items-center gap-1 cursor-pointer">
                        <input type="radio" name="size" value="64" class="accent-blue-500">
                        <span class="text-gray-300 text-xs">QWORD</span>
                    </label>
                    <label class="flex items-center gap-1 cursor-pointer">
                        <input type="radio" name="size" value="32" class="accent-blue-500">
                        <span class="text-gray-300 text-xs">DWORD</span>
                    </label>
                    <label class="flex items-center gap-1 cursor-pointer">
                        <input type="radio" name="size" value="16" class="accent-blue-500">
                        <span class="text-gray-300 text-xs">WORD</span>
                    </label>
                    <label class="flex items-center gap-1 cursor-pointer">
                        <input type="radio" name="size" value="8" class="accent-blue-500">
                        <span class="text-gray-300 text-xs">BYTE</span>
                    </label>
                </div>
            </div>
            
            <!-- Integer Inputs -->
            <div class="grid grid-cols-1 gap-6">
                <div>
                    <label for="hexadecimal" class="block mb-2 text-sm font-medium text-gray-300">Hexadecimal</label>
                    <input type="text" id="hexadecimal" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none uppercase" placeholder="e.g., FF">
                </div>
                <div>
                    <label for="hexadecimal-swapped" class="block mb-2 text-sm font-medium text-gray-300">Hexadecimal (byte-swapped)</label>
                    <input type="text" id="hexadecimal-swapped" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none uppercase" placeholder="e.g., FF">
                </div>
                <div>
                    <label for="decimal" class="block mb-2 text-sm font-medium text-gray-300">Decimal</label>
                    <input type="text" id="decimal" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none" placeholder="e.g., 255">
                </div>
                <div>
                    <label for="octal" class="block mb-2 text-sm font-medium text-gray-300">Octal</label>
                    <input type="text" id="octal" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none" placeholder="e.g., 377">
                </div>
                <div>
                    <label for="binary-stream" class="block mb-2 text-sm font-medium text-gray-300">Binary Stream</label>
                    <input type="text" id="binary-stream" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none" placeholder="e.g., 11001010">
                </div>
            </div>
            
            <!-- Interactive Binary Input -->
            <div>
                <label for="binary" class="block mb-2 text-sm font-medium text-gray-300">Binary Bits</label>
                <div id="binary-bits" class="flex flex-col gap-1 mb-2"></div>
                <input type="text" id="binary" class="hidden" autocomplete="off">
            </div>

            <!-- Separator line -->
            <div class="border-t border-gray-700 my-2"></div>

            <!-- Time and Date Inputs -->
            <div class="grid grid-cols-1 gap-6">
                <div id="floating-point-wrapper">
                    <label for="floating-point" class="block mb-2 text-sm font-medium text-gray-300">Floating Point (IEEE 754)</label>
                    <input type="text" id="floating-point" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none disabled:opacity-50" placeholder="Active for 32/64-bit">
                </div>
                <div>
                    <label class="block mb-2 text-sm font-medium text-gray-300">UNIX Time (Epoch: 1970-01-01)</label>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <input type="date" id="unix-date" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none">
                        <input type="time" id="unix-time" step="1" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none">
                    </div>
                </div>
                <div>
                    <label class="block mb-2 text-sm font-medium text-gray-300">Cocoa Core Data Time (Epoch: 2001-01-01)</label>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <input type="date" id="cocoa-date" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none">
                        <input type="time" id="cocoa-time" step="1" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none">
                    </div>
                </div>
                <div>
                    <label class="block mb-2 text-sm font-medium text-gray-300">Mac HFS+ Time (Epoch: 1904-01-01)</label>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <input type="date" id="hfs-date" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none">
                        <input type="time" id="hfs-time" step="1" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none">
                    </div>
                </div>
                <div>
                    <label for="ipv4-address" class="block mb-2 text-sm font-medium text-gray-300">IPv4 Address</label>
                    <input type="text" id="ipv4-address" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none disabled:opacity-50" placeholder="Active for 32-bit">
                </div>
                <div>
                    <label for="rgb-hex-text" class="block mb-2 text-sm font-medium text-gray-300">RGB Color</label>
                    <div class="flex items-center gap-4">
                        <input type="color" id="rgb-color-picker" class="p-1 h-14 w-16 block bg-gray-700 border-0 cursor-pointer rounded-lg disabled:opacity-50 disabled:cursor-not-allowed">
                        <input type="text" id="rgb-hex-text" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none uppercase disabled:opacity-50" placeholder="Active for 32-bit">
                    </div>
                </div>
            </div>
        </div>

    </div>

    <script>
        // --- DOM Elements ---
        const decimalInput = document.getElementById('decimal');
        const hexadecimalInput = document.getElementById('hexadecimal');
        const hexSwappedInput = document.getElementById('hexadecimal-swapped');
        const binaryInput = document.getElementById('binary');
        const octalInput = document.getElementById('octal');
        const binaryStreamInput = document.getElementById('binary-stream');
        const ipv4Input = document.getElementById('ipv4-address');
        const binaryBitsDiv = document.getElementById('binary-bits');
        const signedCheckbox = document.getElementById('signed');
        const sizeRadios = document.querySelectorAll('input[name="size"]');
        const floatInput = document.getElementById('floating-point');
        const rgbHexText = document.getElementById('rgb-hex-text');
        const rgbColorPicker = document.getElementById('rgb-color-picker');
        
        const unixDate = document.getElementById('unix-date');
        const unixTime = document.getElementById('unix-time');
        const cocoaDate = document.getElementById('cocoa-date');
        const cocoaTime = document.getElementById('cocoa-time');
        const hfsDate = document.getElementById('hfs-date');
        const hfsTime = document.getElementById('hfs-time');

        let isUpdatingDateTime = false;

        // --- State & Constants ---
        let bitLength = 64;
        const COCOA_EPOCH_OFFSET = 978307200n; // Seconds between 1970 and 2001
        const HFS_EPOCH_OFFSET = 2082844800n;   // Seconds between 1904 and 1970

        // --- Helper Functions ---
        const getBitLength = () => bitLength;
        const padBinary = (bin, length = 64) => bin.padStart(length, '0');

        function swapBytes(hexString, bits) {
            if (!hexString) return '';
            const hexLen = bits / 4;
            const paddedHex = hexString.padStart(hexLen, '0');
            const bytes = paddedHex.match(/.{1,2}/g) || [];
            return bytes.reverse().join('');
        }

        function setBitLength(newLength, triggerUpdate = false) {
            bitLength = parseInt(newLength, 10);
            document.querySelector(`input[name="size"][value="${bitLength}"]`).checked = true;
            updateFieldStates();
            if (triggerUpdate) {
                let currentVal = decimalInput.value || '0';
                updateValues('decimal', currentVal);
            }
        }

        function updateFieldStates() {
            const len = getBitLength();
            floatInput.disabled = (len !== 32 && len !== 64);
            if(floatInput.disabled) floatInput.value = '';

            ipv4Input.disabled = (len !== 32);
            if(ipv4Input.disabled) ipv4Input.value = '';

            rgbHexText.disabled = (len !== 32);
            rgbColorPicker.disabled = (len !== 32);
            if(rgbHexText.disabled) {
                rgbHexText.value = '';
                rgbColorPicker.value = '#000000';
            }
        }

        function renderBinaryBits(binStr) {
            binStr = padBinary(binStr, 64);
            binaryBitsDiv.innerHTML = '';
            const activeBitLength = getBitLength();

            for (let line = 0; line < 4; line++) {
                const lineDiv = document.createElement('div');
                lineDiv.className = 'flex gap-4 justify-center items-end';
                for (let group = 0; group < 4; group++) {
                    const groupDiv = document.createElement('div');
                    groupDiv.className = 'flex flex-col items-end';
                    const bitsRow = document.createElement('div');
                    bitsRow.className = 'flex gap-2';
                    for (let b = 0; b < 4; b++) {
                        const bitIdx = line * 16 + group * 4 + b;
                        const bit = binStr[bitIdx];
                        const isActive = (64 - bitIdx) <= activeBitLength;
                        const span = document.createElement('span');
                        span.textContent = bit;
                        span.className = `select-none px-1 py-0.5 rounded text-sm font-bold transition w-6 text-center
                            ${bit === '1' ? 'bg-blue-500 text-white' : 'bg-gray-600 text-gray-200'}
                            ${isActive ? 'cursor-pointer hover:ring-2 hover:ring-blue-400' : 'opacity-40 cursor-not-allowed'}`;
                        if (isActive) {
                            span.addEventListener('click', () => {
                                let bitsArr = binStr.split('');
                                bitsArr[bitIdx] = bitsArr[bitIdx] === '1' ? '0' : '1';
                                let newBin = bitsArr.join('').slice(-activeBitLength);
                                updateValues('binary', newBin);
                            });
                        }
                        bitsRow.appendChild(span);
                    }
                    const lsbIdx = 63 - (line * 16 + group * 4 + 3);
                    const idxLabel = document.createElement('span');
                    idxLabel.textContent = lsbIdx;
                    idxLabel.className = 'block text-xs text-gray-400 w-full text-right mt-0.5';
                    groupDiv.appendChild(bitsRow);
                    groupDiv.appendChild(idxLabel);
                    lineDiv.appendChild(groupDiv);
                }
                binaryBitsDiv.appendChild(lineDiv);
            }
        }
        
        function clearAllInputs(skipId = null) {
            const inputs = [decimalInput, hexadecimalInput, hexSwappedInput, octalInput, binaryStreamInput, ipv4Input, floatInput, rgbHexText, unixDate, unixTime, cocoaDate, cocoaTime, hfsDate, hfsTime];
            inputs.forEach(input => { if (input.id !== skipId) input.value = ''; });
            if (skipId !== 'rgb-color-picker') rgbColorPicker.value = '#000000';
        }

        function setDateTimePickers(date, datePicker, timePicker) {
            if (isNaN(date.getTime())) {
                datePicker.value = '';
                timePicker.value = '';
                return;
            }
            const year = date.getUTCFullYear();
            const month = (date.getUTCMonth() + 1).toString().padStart(2, '0');
            const day = date.getUTCDate().toString().padStart(2, '0');
            datePicker.value = `${year}-${month}-${day}`;
            
            const hours = date.getUTCHours().toString().padStart(2, '0');
            const minutes = date.getUTCMinutes().toString().padStart(2, '0');
            const seconds = date.getUTCSeconds().toString().padStart(2, '0');
            timePicker.value = `${hours}:${minutes}:${seconds}`;
        }

        // --- Core Conversion Logic ---
        function updateValues(sourceId, sourceValue) {
            if (sourceValue === '' || sourceValue === '-') {
                clearAllInputs(sourceId);
                renderBinaryBits('0');
                return;
            }

            let decimalValue;
            let binStr = '';
            const isSigned = signedCheckbox.checked;
            const len = getBitLength();

            try {
                let normalHex;
                switch (sourceId) {
                    case 'decimal':
                        if (/^-?\d+$/.test(sourceValue)) decimalValue = BigInt(sourceValue);
                        break;
                    case 'hexadecimal-swapped':
                        if (/^[0-9A-Fa-f]*$/.test(sourceValue)) {
                             normalHex = swapBytes(sourceValue, len);
                        }
                        // Fallthrough to hexadecimal case with the un-swapped value
                    case 'hexadecimal':
                        if (/^[0-9A-Fa-f]+$/.test(normalHex || sourceValue)) {
                            let num = BigInt('0x' + (normalHex || sourceValue));
                            decimalValue = isSigned && num >= 2n ** BigInt(len - 1) ? num - 2n ** BigInt(len) : num;
                        }
                        break;
                    case 'binary':
                    case 'binary-stream':
                        if (/^[01]+$/.test(sourceValue)) {
                            let num = BigInt('0b' + padBinary(sourceValue, len).slice(-len));
                            decimalValue = isSigned && sourceValue.padStart(len, '0')[0] === '1' ? num - 2n ** BigInt(len) : num;
                        }
                        break;
                    case 'octal':
                        if (/^[0-7]+$/.test(sourceValue)) {
                            let num = BigInt('0o' + sourceValue);
                            decimalValue = isSigned && num >= 2n ** BigInt(len - 1) ? num - 2n ** BigInt(len) : num;
                        }
                        break;
                    case 'ipv4-address':
                         if (len === 32) {
                            const octets = sourceValue.split('.').map(o => parseInt(o, 10));
                            if (octets.length === 4 && octets.every(o => !isNaN(o) && o >= 0 && o <= 255)) {
                                const val = (BigInt(octets[0]) << 24n) | (BigInt(octets[1]) << 16n) | (BigInt(octets[2]) << 8n) | BigInt(octets[3]);
                                decimalValue = isSigned ? BigInt.asIntN(32, val) : val;
                            }
                         }
                         break;
                    case 'rgb-color':
                         if (len === 32) {
                            const hex = sourceValue.replace('#', '');
                            if (/^[0-9A-Fa-f]{6}$/.test(hex)) {
                                const val = BigInt('0x' + hex);
                                decimalValue = isSigned ? BigInt.asIntN(32, val) : val;
                            }
                         }
                         break;
                    case 'floating-point':
                         if (!isNaN(parseFloat(sourceValue)) && isFinite(sourceValue)) {
                           if (len === 32) {
                                let buf = new ArrayBuffer(4);
                                new DataView(buf).setFloat32(0, parseFloat(sourceValue), false);
                                let u32 = new DataView(buf).getUint32(0, false);
                                decimalValue = isSigned ? BigInt.asIntN(32, BigInt(u32)) : BigInt(u32);
                           } else if (len === 64) {
                                let buf = new ArrayBuffer(8);
                                new DataView(buf).setFloat64(0, parseFloat(sourceValue), false);
                                decimalValue = isSigned ? new DataView(buf).getBigInt64(0, false) : new DataView(buf).getBigUint64(0, false);
                           }
                        }
                        break;
                }
            } catch (e) { console.error(e); }

            if (typeof decimalValue !== 'undefined') {
                binStr = (isSigned && decimalValue < 0 ? decimalValue + (2n ** BigInt(len)) : decimalValue).toString(2);
                binStr = padBinary(binStr, 64);
                const activeBinStr = binStr.slice(-len);

                if (sourceId !== 'decimal') decimalInput.value = decimalValue.toString();
                
                const normalHexValue = BigInt('0b' + activeBinStr).toString(16).toUpperCase();
                if (sourceId !== 'hexadecimal') hexadecimalInput.value = normalHexValue;
                if (sourceId !== 'hexadecimal-swapped') hexSwappedInput.value = swapBytes(normalHexValue, len);

                if (sourceId !== 'octal') octalInput.value = BigInt('0b' + activeBinStr).toString(8);

                const displayBinStr = activeBinStr.replace(/^0+(?!$)/, '') || '0';
                if (sourceId !== 'binary') binaryInput.value = displayBinStr;
                if (sourceId !== 'binary-stream') binaryStreamInput.value = displayBinStr;
                renderBinaryBits(binStr);
                
                if (len === 32) {
                    const num32 = BigInt.asUintN(32, BigInt('0b' + activeBinStr));
                    
                    // IPv4 update
                    const o1 = (num32 >> 24n) & 255n;
                    const o2 = (num32 >> 16n) & 255n;
                    const o3 = (num32 >> 8n) & 255n;
                    const o4 = num32 & 255n;
                    if (sourceId !== 'ipv4-address') ipv4Input.value = `${o1}.${o2}.${o3}.${o4}`;

                    // RGB Color update
                    const colorVal = num32 & 0xFFFFFFn; // Get lower 24 bits
                    const hexColor = colorVal.toString(16).padStart(6, '0').toUpperCase();
                    if (sourceId !== 'rgb-color' && sourceId !== 'rgb-hex-text' && sourceId !== 'rgb-color-picker') {
                        rgbHexText.value = hexColor;
                        rgbColorPicker.value = `#${hexColor}`;
                    }

                    // Float update
                    let u32 = parseInt(activeBinStr, 2);
                    let buf = new ArrayBuffer(4);
                    new DataView(buf).setUint32(0, u32, false);
                    let f = new DataView(buf).getFloat32(0, false);
                    if (sourceId !== 'floating-point') floatInput.value = isFinite(f) ? f.toString() : 'NaN';
                } else {
                    if (sourceId !== 'ipv4-address') ipv4Input.value = '';
                    if (sourceId !== 'rgb-color' && sourceId !== 'rgb-hex-text' && sourceId !== 'rgb-color-picker') {
                        rgbHexText.value = '';
                        rgbColorPicker.value = '#000000';
                    }
                }
                
                if (len === 64) {
                    let buf = new ArrayBuffer(8);
                    new DataView(buf).setBigUint64(0, BigInt('0b' + binStr), false);
                    let d = new DataView(buf).getFloat64(0, false);
                    if (sourceId !== 'floating-point') floatInput.value = isFinite(d) ? d.toString() : 'NaN';
                } else if (len !== 32) {
                     if (sourceId !== 'floating-point') floatInput.value = '';
                }

                isUpdatingDateTime = true;
                try {
                    const valForTimestamp = isSigned ? decimalValue : BigInt('0b' + activeBinStr);
                    const unixTimestampMs = Number(valForTimestamp) * 1000;
                    const cocoaTimestampMs = Number(valForTimestamp + COCOA_EPOCH_OFFSET) * 1000;
                    const hfsTimestampMs = Number(valForTimestamp - HFS_EPOCH_OFFSET) * 1000;
                    
                    setDateTimePickers(new Date(unixTimestampMs), unixDate, unixTime);
                    setDateTimePickers(new Date(cocoaTimestampMs), cocoaDate, cocoaTime);
                    setDateTimePickers(new Date(hfsTimestampMs), hfsDate, hfsTime);
                } catch {
                   [unixDate, unixTime, cocoaDate, cocoaTime, hfsDate, hfsTime].forEach(el => el.value = '');
                } finally {
                    setTimeout(() => isUpdatingDateTime = false, 0);
                }
            } else if (sourceId) {
                clearAllInputs(sourceId);
            }
        }
        
        // --- Event Listener Helpers ---
        function createDateTimeHandler(dateEl, timeEl, epochOffset = 0n) {
            return () => {
                if (isUpdatingDateTime) return;
                const dateStr = dateEl.value;
                const timeStr = timeEl.value;
                if (dateStr && timeStr) {
                    const utcDate = new Date(`${dateStr}T${timeStr}Z`);
                    const unixTimestamp = BigInt(Math.floor(utcDate.getTime() / 1000));
                    const newDecimalValue = unixTimestamp - epochOffset;
                    updateValues('decimal', newDecimalValue.toString());
                }
            };
        }

        // --- Event Listeners ---
        function addSanitizingListener(element, regex, sourceId) {
             element.addEventListener('input', (e) => {
                const input = e.target;
                const originalValue = input.value;
                const cursorPos = input.selectionStart;
                let sanitizedValue = originalValue.replace(regex, '');
                
                if (sourceId === 'decimal' && sanitizedValue.lastIndexOf('-') > 0) {
                     sanitizedValue = sanitizedValue.charAt(0) + sanitizedValue.slice(1).replace(/-/g, "");
                }
                
                if (['hexadecimal', 'hexadecimal-swapped', 'rgb-hex-text'].includes(sourceId)) {
                    sanitizedValue = sanitizedValue.toUpperCase();
                }

                if (originalValue !== sanitizedValue) {
                    input.value = sanitizedValue;
                    const diff = originalValue.length - sanitizedValue.length;
                    input.setSelectionRange(cursorPos - diff, cursorPos - diff);
                }
                
                if (sourceId === 'rgb-hex-text') {
                    sanitizedValue = sanitizedValue.substring(0,6);
                    input.value = sanitizedValue;
                    if (sanitizedValue.length === 6) {
                        rgbColorPicker.value = `#${sanitizedValue}`;
                        updateValues('rgb-color', sanitizedValue);
                    }
                } else {
                    updateValues(sourceId, sanitizedValue);
                }
            });
        }
        
        addSanitizingListener(hexadecimalInput, /[^0-9a-fA-F]/g, 'hexadecimal');
        addSanitizingListener(hexSwappedInput, /[^0-9a-fA-F]/g, 'hexadecimal-swapped');
        addSanitizingListener(decimalInput, /[^-0-9]/g, 'decimal');
        addSanitizingListener(octalInput, /[^0-7]/g, 'octal');
        addSanitizingListener(binaryStreamInput, /[^01]/g, 'binary-stream');
        addSanitizingListener(ipv4Input, /[^0-9.]/g, 'ipv4-address');
        addSanitizingListener(floatInput, /[^0-9.eE+-]/g, 'floating-point');
        addSanitizingListener(rgbHexText, /[^0-9a-fA-F]/g, 'rgb-hex-text');

        rgbColorPicker.addEventListener('input', (e) => {
            const hex = e.target.value.substring(1).toUpperCase();
            rgbHexText.value = hex;
            updateValues('rgb-color', hex);
        });

        const unixHandler = createDateTimeHandler(unixDate, unixTime, 0n);
        unixDate.addEventListener('input', unixHandler);
        unixTime.addEventListener('input', unixHandler);

        const cocoaHandler = createDateTimeHandler(cocoaDate, cocoaTime, COCOA_EPOCH_OFFSET);
        cocoaDate.addEventListener('input', cocoaHandler);
        cocoaTime.addEventListener('input', cocoaHandler);
        
        const hfsHandler = createDateTimeHandler(hfsDate, hfsTime, -HFS_EPOCH_OFFSET);
        hfsDate.addEventListener('input', hfsHandler);
        hfsTime.addEventListener('input', hfsHandler);

        signedCheckbox.addEventListener('change', () => updateValues('decimal', decimalInput.value || '0'));
        sizeRadios.forEach(radio => radio.addEventListener('change', (e) => setBitLength(e.target.value, true)));

        // --- Initial Setup ---
        window.addEventListener('load', () => {
            setBitLength(64);
            clearAllInputs();
            renderBinaryBits('0');
        });

    </script>
</body>
</html>

