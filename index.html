<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Number Base Converter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Fira Mono', 'Consolas', 'Menlo', 'Monaco', monospace, sans-serif;
        }
        /* Simple focus style for better accessibility */
        input:focus {
            box-shadow: 0 0 0 2px #60a5fa; /* blue-400 */
        }
        /* Use monospace for all converter fields */
        #hexadecimal, #decimal, #octal, #binary, #binary-bits, #binary-bits * {
            font-family: 'Fira Mono', 'Consolas', 'Menlo', 'Monaco', monospace, 'Inter', sans-serif !important;
        }
    </style>
</head>
<body class="bg-gray-900 flex items-center justify-center min-h-screen">

    <div class="bg-gray-800 p-8 rounded-2xl shadow-2xl w-full max-w-2xl mx-4">
        
        <h1 class="text-3xl font-bold text-center text-white mb-2">Number Base Converter</h1>
        <p class="text-center text-gray-400 mb-8">Convert between Hexadecimal, Decimal, Octal and Binary.</p>

        <div class="grid grid-cols-1 gap-6">
            <!-- Signed Checkbox and Size Switch on the same line -->
            <div class="flex items-center gap-6 mb-2">
                <!-- Signed Checkbox -->
                <div class="flex items-center">
                    <input id="signed" type="checkbox" class="mr-2 accent-blue-500 w-5 h-5">
                    <label for="signed" class="text-gray-300 text-sm font-medium select-none cursor-pointer">Signed</label>
                </div>
                <!-- Size Switch -->
                <div class="flex items-center gap-4">
                    <label class="text-gray-300 text-sm font-medium">Size:</label>
                    <label class="flex items-center gap-1 cursor-pointer">
                        <input type="radio" name="size" value="64" class="accent-blue-500" checked>
                        <span class="text-gray-300 text-xs">QWORD</span>
                    </label>
                    <label class="flex items-center gap-1 cursor-pointer">
                        <input type="radio" name="size" value="32" class="accent-blue-500">
                        <span class="text-gray-300 text-xs">DWORD</span>
                    </label>
                    <label class="flex items-center gap-1 cursor-pointer">
                        <input type="radio" name="size" value="16" class="accent-blue-500">
                        <span class="text-gray-300 text-xs">WORD</span>
                    </label>
                    <label class="flex items-center gap-1 cursor-pointer">
                        <input type="radio" name="size" value="8" class="accent-blue-500">
                        <span class="text-gray-300 text-xs">BYTE</span>
                    </label>
                </div>
            </div>
            <!-- Hexadecimal Input -->
            <div>
                <label for="hexadecimal" class="block mb-2 text-sm font-medium text-gray-300">Hexadecimal</label>
                <input type="text" id="hexadecimal" class="bg-gray-700 border-0 text-white text-lg rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-4 outline-none uppercase" placeholder="e.g., FF">
            </div>

            <!-- Decimal Input -->
            <div>
                <label for="decimal" class="block mb-2 text-sm font-medium text-gray-300">Decimal</label>
                <input type="text" id="decimal" class="bg-gray-700 border-0 text-white text-lg rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-4 outline-none" placeholder="e.g., 255">
            </div>

            <!-- Octal Input -->
            <div>
                <label for="octal" class="block mb-2 text-sm font-medium text-gray-300">Octal</label>
                <input type="text" id="octal" class="bg-gray-700 border-0 text-white text-lg rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-4 outline-none" placeholder="e.g., 377">
            </div>

            <!-- Binary Stream Input -->
            <div>
                <label for="binary-stream" class="block mb-2 text-sm font-medium text-gray-300">Binary Stream</label>
                <input type="text" id="binary-stream" class="bg-gray-700 border-0 text-white text-lg rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-4 outline-none font-mono" placeholder="e.g., 11001010">
            </div>

            <!-- Binary Input -->
            <div>
                <label for="binary" class="block mb-2 text-sm font-medium text-gray-300">Binary</label>
                <div id="binary-bits" class="flex flex-col gap-1 mb-2"></div>
                <input type="text" id="binary" class="hidden" autocomplete="off">
            </div>
        </div>

    </div>

    <script>
const decimalInput = document.getElementById('decimal');
const hexadecimalInput = document.getElementById('hexadecimal');
const binaryInput = document.getElementById('binary');
const octalInput = document.getElementById('octal');
const binaryStreamInput = document.getElementById('binary-stream');
const binaryBitsDiv = document.getElementById('binary-bits');
const signedCheckbox = document.getElementById('signed');
const sizeRadios = document.querySelectorAll('input[name="size"]');

const inputs = [decimalInput, hexadecimalInput, binaryInput, octalInput, binaryStreamInput];

let bitLength = 64; // Default QWORD

function getBitLength() {
    return bitLength;
}

// Always show 64 bits, but only allow interaction for active bits
function getActiveBitsMask() {
    // Returns an array of 64 booleans, true if bit is active
    const len = getBitLength();
    const mask = Array(64).fill(false);
    for (let i = 64 - len; i < 64; i++) mask[i] = true;
    return mask;
}

// Helper to pad binary string to 64 bits
function padBinary(bin, length = 64) {
    return bin.padStart(length, '0');
}

// Render clickable binary bits, 4 lines of 16 bits, grouped by 4, MSB left, LSB right
function renderBinaryBits(binStr) {
    binStr = padBinary(binStr, 64).slice(-64);
    binaryBitsDiv.innerHTML = '';
    const mask = getActiveBitsMask();

    for (let line = 0; line < 4; line++) {
        // Bits line
        const lineDiv = document.createElement('div');
        lineDiv.className = 'flex gap-4 justify-center items-end';

        for (let group = 0; group < 4; group++) {
            // Bits group
            const groupDiv = document.createElement('div');
            groupDiv.className = 'flex flex-col items-end';

            // Bits row
            const bitsRow = document.createElement('div');
            bitsRow.className = 'flex gap-2';

            for (let b = 0; b < 4; b++) {
                const bitIdx = line * 16 + group * 4 + b;
                const bit = binStr[bitIdx];
                const isActive = mask[bitIdx];
                const span = document.createElement('span');
                span.textContent = bit;
                span.className = `select-none px-1 py-0.5 rounded text-sm font-mono font-bold transition w-6 text-center
                    ${bit === '1' ? 'bg-blue-500 text-white' : 'bg-gray-600 text-gray-200'}
                    ${isActive ? 'cursor-pointer hover:ring-2 hover:ring-blue-400' : 'opacity-40 cursor-not-allowed'}`;
                span.dataset.index = bitIdx;
                if (isActive) {
                    span.addEventListener('click', () => {
                        let bitsArr = binStr.split('');
                        bitsArr[bitIdx] = bitsArr[bitIdx] === '1' ? '0' : '1';
                        let newBin = bitsArr.join('');
                        let activeBits = newBin.slice(-bitLength);
                        binaryInput.value = activeBits.replace(/^0+/, '') || '0';
                        updateValues('binary', activeBits);
                    });
                }
                bitsRow.appendChild(span);
            }

            // LSB index for this group (rightmost bit in group)
            const groupStartBitIdx = line * 16 + group * 4;
            const lsbIdx = 63 - (groupStartBitIdx + 3);
            const idxLabel = document.createElement('span');
            idxLabel.textContent = lsbIdx;
            idxLabel.className = 'block text-xs text-gray-400 w-full text-right mt-0.5';

            groupDiv.appendChild(bitsRow);
            groupDiv.appendChild(idxLabel);

            lineDiv.appendChild(groupDiv);
        }
        binaryBitsDiv.appendChild(lineDiv);
    }
}

// Render static LSB indexes under each 4-bit group
function renderBinaryIndexes() {
    binaryIndexesDiv.innerHTML = '';
    for (let line = 0; line < 4; line++) {
        const lineDiv = document.createElement('div');
        lineDiv.className = 'flex gap-4 justify-center';
        for (let group = 0; group < 4; group++) {
            const groupDiv = document.createElement('div');
            groupDiv.className = 'flex flex-col items-end w-[4.5em]';
            const empty = document.createElement('span');
            empty.className = 'block h-0';
            groupDiv.appendChild(empty);
            // LSB index for this group
            const bitIdx = line * 16 + group * 4;
            const lsbIdx = 63 - bitIdx - 3;
            const idxLabel = document.createElement('span');
            idxLabel.textContent = lsbIdx;
            idxLabel.className = 'block text-xs text-gray-400 w-full text-right';
            groupDiv.appendChild(idxLabel);
            lineDiv.appendChild(groupDiv);
        }
        binaryIndexesDiv.appendChild(lineDiv);
    }
}

// Input filters
hexadecimalInput.addEventListener('input', (e) => {
    // Accept both lowercase and uppercase A-F, and allow pasting
    let val = e.target.value;
    // Only keep valid hex chars, then uppercase
    val = val.replace(/[^0-9a-fA-F]/g, '').toUpperCase();
    // Limit to max hex digits for current bit length
    val = val.slice(0, getBitLength() / 4);
    // Set value and update
    if (hexadecimalInput.value !== val) hexadecimalInput.value = val;
    updateValues('hexadecimal', val);
});
decimalInput.addEventListener('input', (e) => {
    let isSigned = signedCheckbox.checked;
    let maxLen = getBitLength();
    let max = isSigned ? (2n ** BigInt(maxLen - 1n) - 1n) : (2n ** BigInt(maxLen) - 1n);
    let min = isSigned ? -(2n ** BigInt(maxLen - 1n)) : 0n;
    let val = e.target.value.replace(/[^0-9\-]/g, '');
    if (isSigned && val.startsWith('-')) {
        val = '-' + val.slice(1).replace(/-/g, '');
    } else {
        val = val.replace(/-/g, '');
    }
    // Clamp value
    try {
        let n = BigInt(val || '0');
        if (n > max) n = max;
        if (n < min) n = min;
        decimalInput.value = n.toString();
        updateValues('decimal', n.toString());
    } catch {
        decimalInput.value = '';
        updateValues('decimal', '');
    }
});
octalInput.addEventListener('input', (e) => {
    let val = e.target.value.replace(/[^0-7]/g, '').slice(0, Math.ceil(getBitLength() / 3));
    octalInput.value = val;
    updateValues('octal', val);
});
binaryInput.addEventListener('input', (e) => {
    let val = e.target.value.replace(/[^01]/g, '').slice(-getBitLength());
    binaryInput.value = val;
    updateValues('binary', val);
});

// Binary Stream input: mirror binary bits, allow copy/paste
binaryStreamInput.addEventListener('input', (e) => {
    let val = e.target.value.replace(/[^01]/g, '').slice(-getBitLength());
    binaryStreamInput.value = val;
    binaryInput.value = val;
    updateValues('binary', val);
});

// Add event listener to all input fields except binary (handled separately above)
[decimalInput].forEach(input => {
    input.addEventListener('blur', (e) => {
        updateValues('decimal', input.value);
    });
});

// Signed checkbox triggers recalculation
signedCheckbox.addEventListener('change', () => {
    let binVal = binaryInput.value || '0';
    updateValues('binary', binVal);
});

// Size radio triggers recalculation and limits
sizeRadios.forEach(radio => {
    radio.addEventListener('change', () => {
        bitLength = parseInt(document.querySelector('input[name="size"]:checked').value, 10);
        let binVal = padBinary(binaryInput.value || '0', bitLength).slice(-bitLength);
        binaryInput.value = binVal.replace(/^0+/, '') || '0';
        updateValues('binary', binVal);
    });
});

// Initial render
renderBinaryBits('0'.repeat(64));

function updateValues(sourceId, sourceValue) {
    let decimalValue;
    let binStr = '';
    let isSigned = signedCheckbox.checked;
    let len = getBitLength();

    try {
        switch (sourceId) {
            case 'decimal':
                if (/^-?\d+$/.test(sourceValue)) {
                    let num = BigInt(sourceValue);
                    if (isSigned) {
                        let min = -(2n ** BigInt(len - 1));
                        let max = 2n ** BigInt(len - 1) - 1n;
                        if (num < min) num = min;
                        if (num > max) num = max;
                        decimalValue = num;
                        binStr = (num < 0 ? (num + 2n ** BigInt(len)) : num).toString(2);
                    } else {
                        let min = 0n;
                        let max = 2n ** BigInt(len) - 1n;
                        if (num < min) num = min;
                        if (num > max) num = max;
                        decimalValue = num;
                        binStr = num.toString(2);
                    }
                }
                break;
            case 'hexadecimal':
                if (/^[0-9A-Fa-f]+$/.test(sourceValue)) {
                    let num = BigInt('0x' + sourceValue);
                    num = num & (2n ** BigInt(len) - 1n);
                    if (isSigned && num >= 2n ** BigInt(len - 1)) {
                        decimalValue = num - 2n ** BigInt(len);
                    } else {
                        decimalValue = num;
                    }
                    binStr = num.toString(2);
                }
                break;
            case 'binary':
            case 'binary-stream':
                if (/^[01]+$/.test(sourceValue)) {
                    let bin = padBinary(sourceValue, len).slice(-len);
                    let num = BigInt('0b' + bin);
                    if (isSigned && bin[0] === '1') {
                        decimalValue = num - 2n ** BigInt(len);
                    } else {
                        decimalValue = num;
                    }
                    binStr = bin;
                }
                break;
            case 'octal':
                if (/^[0-7]+$/.test(sourceValue)) {
                    let num = BigInt('0o' + sourceValue);
                    num = num & (2n ** BigInt(len) - 1n);
                    if (isSigned && num >= 2n ** BigInt(len - 1)) {
                        decimalValue = num - 2n ** BigInt(len);
                    } else {
                        decimalValue = num;
                    }
                    binStr = num.toString(2);
                }
                break;
        }
    } catch (e) {
        decimalValue = undefined;
    }

    if (typeof decimalValue !== 'undefined' && decimalValue !== null) {
        binStr = padBinary(binStr, 64).slice(-64);

        // Remove leading zeros for display (but keep at least one digit)
        let hexVal = BigInt('0b' + binStr.slice(-len)).toString(16).toUpperCase();
        let octVal = BigInt('0b' + binStr.slice(-len)).toString(8);
        let decVal = decimalValue.toString();

        // Remove leading zeros (but keep at least one digit)
        hexVal = hexVal.replace(/^0+(?!$)/, '');
        octVal = octVal.replace(/^0+(?!$)/, '');
        decVal = decVal.replace(/^0+(?!$)/, '');

        if (sourceId !== 'decimal') decimalInput.value = decVal;
        if (sourceId !== 'hexadecimal') hexadecimalInput.value = hexVal;
        if (sourceId !== 'binary') {
            binaryInput.value = binStr.slice(-len).replace(/^0+(?!$)/, '') || '0';
            binaryStreamInput.value = binStr.slice(-len).replace(/^0+(?!$)/, '') || '0';
            renderBinaryBits(binStr);
        } else {
            binaryStreamInput.value = binStr.slice(-len).replace(/^0+(?!$)/, '') || '0';
            renderBinaryBits(binStr);
        }
        if (sourceId !== 'octal') octalInput.value = octVal;
    } else {
        clearAllInputs(sourceId);
        renderBinaryBits('0'.repeat(64));
        binaryStreamInput.value = '';
    }
}

function clearAllInputs(skipId = null) {
    inputs.forEach(input => {
        if (input.id !== skipId) {
            input.value = '';
        }
    });
}
</script>
</body>
</html>

