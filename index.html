<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Converter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Fira+Mono&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Simple focus style for better accessibility */
        input:focus {
            box-shadow: 0 0 0 2px #60a5fa; /* blue-400 */
        }
        /* Use monospace for all converter fields */
        input {
            font-family: 'Fira Mono', 'Consolas', 'Menlo', 'Monaco', monospace;
        }
        #binary-bits * {
             font-family: 'Fira Mono', 'Consolas', 'Menlo', 'Monaco', monospace;
        }
        /* Style for date/time pickers */
        input[type="date"], input[type="time"] {
            color-scheme: dark;
        }
    </style>
</head>
<body class="bg-gray-900 flex items-center justify-center min-h-screen py-8">

    <div class="bg-gray-800 p-8 rounded-2xl shadow-2xl w-full max-w-2xl mx-4">
        
        <h1 class="text-3xl font-bold text-center text-white mb-2">Data Converter</h1>
        <p class="text-center text-gray-400 mb-8">Convert between Hexadecimal, Decimal, Binary, Float, and more.</p>

        <div class="grid grid-cols-1 gap-6">
            <!-- Controls -->
            <div class="flex items-center gap-6 mb-2">
                <div class="flex items-center">
                    <input id="signed" type="checkbox" class="mr-2 accent-blue-500 w-5 h-5">
                    <label for="signed" class="text-gray-300 text-sm font-medium select-none cursor-pointer">Signed</label>
                </div>
                <div class="flex items-center gap-4 flex-wrap">
                    <label class="text-gray-300 text-sm font-medium">Size:</label>
                    <label class="flex items-center gap-1 cursor-pointer">
                        <input type="radio" name="size" value="64" class="accent-blue-500">
                        <span class="text-gray-300 text-xs">QWORD</span>
                    </label>
                    <label class="flex items-center gap-1 cursor-pointer">
                        <input type="radio" name="size" value="32" class="accent-blue-500">
                        <span class="text-gray-300 text-xs">DWORD</span>
                    </label>
                    <label class="flex items-center gap-1 cursor-pointer">
                        <input type="radio" name="size" value="16" class="accent-blue-500">
                        <span class="text-gray-300 text-xs">WORD</span>
                    </label>
                    <label class="flex items-center gap-1 cursor-pointer">
                        <input type="radio" name="size" value="8" class="accent-blue-500">
                        <span class="text-gray-300 text-xs">BYTE</span>
                    </label>
                </div>
            </div>
            
            <!-- Integer Inputs -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div>
                    <label for="hexadecimal" class="block mb-2 text-sm font-medium text-gray-300">Hexadecimal</label>
                    <input type="text" id="hexadecimal" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none uppercase" placeholder="e.g., FF">
                </div>
                <div>
                    <label for="decimal" class="block mb-2 text-sm font-medium text-gray-300">Decimal</label>
                    <input type="text" id="decimal" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none" placeholder="e.g., 255">
                </div>
                <div>
                    <label for="octal" class="block mb-2 text-sm font-medium text-gray-300">Octal</label>
                    <input type="text" id="octal" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none" placeholder="e.g., 377">
                </div>
                <div>
                    <label for="binary-stream" class="block mb-2 text-sm font-medium text-gray-300">Binary Stream</label>
                    <input type="text" id="binary-stream" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none" placeholder="e.g., 11001010">
                </div>
            </div>
            
            <!-- Interactive Binary Input -->
            <div>
                <label for="binary" class="block mb-2 text-sm font-medium text-gray-300">Binary Bits</label>
                <div id="binary-bits" class="flex flex-col gap-1 mb-2"></div>
                <input type="text" id="binary" class="hidden" autocomplete="off">
            </div>

            <!-- Separator line -->
            <div class="border-t border-gray-700 my-2"></div>

            <!-- Time and Date Inputs -->
            <div class="grid grid-cols-1 gap-4">
                <div id="floating-point-wrapper">
                    <label for="floating-point" class="block mb-2 text-sm font-medium text-gray-300">Floating Point (IEEE 754)</label>
                    <input type="text" id="floating-point" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none disabled:opacity-50" placeholder="Active for 32/64-bit">
                </div>
                 <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <label for="date-input" class="block mb-2 text-sm font-medium text-gray-300">Date (UTC)</label>
                        <input type="date" id="date-input" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none">
                    </div>
                    <div>
                        <label for="time-input" class="block mb-2 text-sm font-medium text-gray-300">Time (UTC)</label>
                        <input type="time" id="time-input" step="1" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none">
                    </div>
                </div>
                <div id="timestamp-wrapper">
                    <label for="timestamp" class="block mb-2 text-sm font-medium text-gray-300">UNIX Timestamp (seconds)</label>
                    <input type="text" id="timestamp" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none" placeholder="Epoch: 1970-01-01">
                </div>
                 <div id="cocoa-timestamp-wrapper">
                    <label for="cocoa-timestamp" class="block mb-2 text-sm font-medium text-gray-300">Cocoa Core Data Timestamp</label>
                    <input type="text" id="cocoa-timestamp" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none" placeholder="Epoch: 2001-01-01">
                </div>
                <div id="hfs-timestamp-wrapper">
                    <label for="hfs-timestamp" class="block mb-2 text-sm font-medium text-gray-300">Mac HFS+ Timestamp</label>
                    <input type="text" id="hfs-timestamp" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none" placeholder="Epoch: 1904-01-01">
                </div>
            </div>
        </div>

    </div>

    <script>
        // --- DOM Elements ---
        const decimalInput = document.getElementById('decimal');
        const hexadecimalInput = document.getElementById('hexadecimal');
        const binaryInput = document.getElementById('binary');
        const octalInput = document.getElementById('octal');
        const binaryStreamInput = document.getElementById('binary-stream');
        const binaryBitsDiv = document.getElementById('binary-bits');
        const signedCheckbox = document.getElementById('signed');
        const sizeRadios = document.querySelectorAll('input[name="size"]');
        const floatInput = document.getElementById('floating-point');
        const timestampInput = document.getElementById('timestamp');
        const cocoaTimestampInput = document.getElementById('cocoa-timestamp');
        const hfsTimestampInput = document.getElementById('hfs-timestamp');
        const dateInput = document.getElementById('date-input');
        const timeInput = document.getElementById('time-input');

        const inputs = [decimalInput, hexadecimalInput, octalInput, binaryStreamInput, floatInput, timestampInput, cocoaTimestampInput, hfsTimestampInput, dateInput, timeInput];
        let isUpdatingDateTime = false;

        // --- State & Constants ---
        let bitLength = 64;
        const COCOA_EPOCH_OFFSET = 978307200n; // Seconds between 1970 and 2001
        const HFS_EPOCH_OFFSET = 2082844800n;   // Seconds between 1904 and 1970

        // --- Helper Functions ---
        const getBitLength = () => bitLength;
        const padBinary = (bin, length = 64) => bin.padStart(length, '0');

        function setBitLength(newLength, triggerUpdate = false) {
            bitLength = parseInt(newLength, 10);
            document.querySelector(`input[name="size"][value="${bitLength}"]`).checked = true;
            updateFieldStates();
            if (triggerUpdate) {
                let currentVal = decimalInput.value || '0';
                updateValues('decimal', currentVal);
            }
        }

        function updateFieldStates() {
            const len = getBitLength();
            floatInput.disabled = (len !== 32 && len !== 64);
            if(floatInput.disabled) floatInput.value = '';
        }

        function renderBinaryBits(binStr) {
            binStr = padBinary(binStr, 64);
            binaryBitsDiv.innerHTML = '';
            const activeBitLength = getBitLength();

            for (let line = 0; line < 4; line++) {
                const lineDiv = document.createElement('div');
                lineDiv.className = 'flex gap-4 justify-center items-end';
                for (let group = 0; group < 4; group++) {
                    const groupDiv = document.createElement('div');
                    groupDiv.className = 'flex flex-col items-end';
                    const bitsRow = document.createElement('div');
                    bitsRow.className = 'flex gap-2';
                    for (let b = 0; b < 4; b++) {
                        const bitIdx = line * 16 + group * 4 + b;
                        const bit = binStr[bitIdx];
                        const isActive = (64 - bitIdx) <= activeBitLength;
                        const span = document.createElement('span');
                        span.textContent = bit;
                        span.className = `select-none px-1 py-0.5 rounded text-sm font-bold transition w-6 text-center
                            ${bit === '1' ? 'bg-blue-500 text-white' : 'bg-gray-600 text-gray-200'}
                            ${isActive ? 'cursor-pointer hover:ring-2 hover:ring-blue-400' : 'opacity-40 cursor-not-allowed'}`;
                        if (isActive) {
                            span.addEventListener('click', () => {
                                let bitsArr = binStr.split('');
                                bitsArr[bitIdx] = bitsArr[bitIdx] === '1' ? '0' : '1';
                                let newBin = bitsArr.join('').slice(-activeBitLength);
                                updateValues('binary', newBin);
                            });
                        }
                        bitsRow.appendChild(span);
                    }
                    const groupStartBitIdx = line * 16 + group * 4;
                    const lsbIdx = 63 - (groupStartBitIdx + 3);
                    const idxLabel = document.createElement('span');
                    idxLabel.textContent = lsbIdx;
                    idxLabel.className = 'block text-xs text-gray-400 w-full text-right mt-0.5';
                    groupDiv.appendChild(bitsRow);
                    groupDiv.appendChild(idxLabel);
                    lineDiv.appendChild(groupDiv);
                }
                binaryBitsDiv.appendChild(lineDiv);
            }
        }
        
        function clearAllInputs(skipId = null) {
            inputs.forEach(input => {
                if (input.id !== skipId) input.value = '';
            });
        }

        // --- Core Conversion Logic ---
        function updateValues(sourceId, sourceValue) {
            if (sourceValue === '' || sourceValue === '-') {
                clearAllInputs(sourceId);
                renderBinaryBits('0');
                return;
            }

            let decimalValue; // This holds the primary integer value
            let binStr = '';
            const isSigned = signedCheckbox.checked;
            const len = getBitLength();

            try {
                let unixTimestamp;
                switch (sourceId) {
                    case 'decimal':
                    case 'timestamp':
                        if (/^-?\d+$/.test(sourceValue)) unixTimestamp = BigInt(sourceValue);
                        break;
                    case 'cocoa-timestamp':
                         if (/^-?\d+$/.test(sourceValue)) unixTimestamp = BigInt(sourceValue) + COCOA_EPOCH_OFFSET;
                        break;
                    case 'hfs-timestamp':
                        if (/^-?\d+$/.test(sourceValue)) unixTimestamp = BigInt(sourceValue) - HFS_EPOCH_OFFSET;
                        break;
                    case 'hexadecimal':
                        if (/^[0-9A-Fa-f]+$/.test(sourceValue)) {
                            let num = BigInt('0x' + sourceValue);
                            binStr = num.toString(2);
                            decimalValue = isSigned && num >= 2n ** BigInt(len - 1) ? num - 2n ** BigInt(len) : num;
                        }
                        break;
                    case 'binary':
                    case 'binary-stream':
                        if (/^[01]+$/.test(sourceValue)) {
                            binStr = sourceValue;
                            let num = BigInt('0b' + padBinary(binStr, len).slice(-len));
                            decimalValue = isSigned && binStr.padStart(len, '0')[0] === '1' ? num - 2n ** BigInt(len) : num;
                        }
                        break;
                    case 'octal':
                        if (/^[0-7]+$/.test(sourceValue)) {
                            let num = BigInt('0o' + sourceValue);
                            binStr = num.toString(2);
                            decimalValue = isSigned && num >= 2n ** BigInt(len - 1) ? num - 2n ** BigInt(len) : num;
                        }
                        break;
                    case 'floating-point':
                        if (!isNaN(parseFloat(sourceValue))) {
                           if (len === 32) {
                                let buf = new ArrayBuffer(4);
                                new DataView(buf).setFloat32(0, parseFloat(sourceValue), false);
                                let u32 = new DataView(buf).getUint32(0, false);
                                binStr = u32.toString(2);
                                decimalValue = isSigned ? BigInt(u32 << 32 >> 32) : BigInt(u32);
                           } else if (len === 64) {
                                let buf = new ArrayBuffer(8);
                                new DataView(buf).setFloat64(0, parseFloat(sourceValue), false);
                                let u64 = new DataView(buf).getBigUint64(0, false);
                                binStr = u64.toString(2);
                                decimalValue = isSigned ? new DataView(buf).getBigInt64(0, false) : u64;
                           }
                        }
                        break;
                }
                
                if (typeof unixTimestamp !== 'undefined') {
                    decimalValue = unixTimestamp;
                }
                if (typeof decimalValue !== 'undefined') {
                    binStr = (isSigned && decimalValue < 0 ? decimalValue + (2n ** BigInt(len)) : decimalValue).toString(2);
                }

            } catch (e) { console.error(e); }

            if (typeof decimalValue !== 'undefined') {
                binStr = padBinary(binStr, 64);
                const activeBinStr = binStr.slice(-len);
                
                if (sourceId !== 'decimal') decimalInput.value = decimalValue.toString();
                if (sourceId !== 'hexadecimal') hexadecimalInput.value = BigInt('0b' + activeBinStr).toString(16).toUpperCase();
                if (sourceId !== 'octal') octalInput.value = BigInt('0b' + activeBinStr).toString(8);

                const displayBinStr = activeBinStr.replace(/^0+(?!$)/, '') || '0';
                if (sourceId !== 'binary') binaryInput.value = displayBinStr;
                if (sourceId !== 'binary-stream') binaryStreamInput.value = displayBinStr;
                renderBinaryBits(binStr);

                if (len === 32) {
                    let u32 = parseInt(binStr.slice(-32), 2);
                    let buf = new ArrayBuffer(4);
                    new DataView(buf).setUint32(0, u32, false);
                    let f = new DataView(buf).getFloat32(0, false);
                    if (sourceId !== 'floating-point') floatInput.value = isFinite(f) ? f.toString() : 'NaN';
                } else if (len === 64) {
                    let buf = new ArrayBuffer(8);
                    new DataView(buf).setBigUint64(0, BigInt('0b' + binStr), false);
                    let d = new DataView(buf).getFloat64(0, false);
                    if (sourceId !== 'floating-point') floatInput.value = isFinite(d) ? d.toString() : 'NaN';
                } else {
                    if (sourceId !== 'floating-point') floatInput.value = '';
                }

                const unsignedVal = BigInt('0b' + activeBinStr);
                const valForTimestamp = isSigned ? decimalValue : unsignedVal;

                if (sourceId !== 'timestamp') timestampInput.value = valForTimestamp.toString();
                if (sourceId !== 'cocoa-timestamp') cocoaTimestampInput.value = (valForTimestamp - COCOA_EPOCH_OFFSET).toString();
                if (sourceId !== 'hfs-timestamp') hfsTimestampInput.value = (valForTimestamp + HFS_EPOCH_OFFSET).toString();
                
                isUpdatingDateTime = true;
                try {
                    const date = new Date(Number(valForTimestamp) * 1000);
                    if (isNaN(date.getTime())) throw new Error("Invalid Date");

                    const year = date.getUTCFullYear();
                    const month = (date.getUTCMonth() + 1).toString().padStart(2, '0');
                    const day = date.getUTCDate().toString().padStart(2, '0');
                    dateInput.value = `${year}-${month}-${day}`;
                    
                    const hours = date.getUTCHours().toString().padStart(2, '0');
                    const minutes = date.getUTCMinutes().toString().padStart(2, '0');
                    const seconds = date.getUTCSeconds().toString().padStart(2, '0');
                    timeInput.value = `${hours}:${minutes}:${seconds}`;

                } catch {
                   dateInput.value = '';
                   timeInput.value = '';
                } finally {
                    setTimeout(() => isUpdatingDateTime = false, 0);
                }
            } else {
                clearAllInputs(sourceId);
            }
        }
        
        // --- Event Listener Helpers ---
        function createIntegerInputHandler(id) { return (e) => updateValues(id, e.target.value); }
        function createTimestampInputHandler(id) { return (e) => updateValues(id, e.target.value); }

        function handleDateTimeChange() {
            if (isUpdatingDateTime) return;
            const dateStr = dateInput.value;
            const timeStr = timeInput.value;
            if (dateStr && timeStr) {
                const [year, month, day] = dateStr.split('-');
                const [hours, minutes, seconds] = timeStr.split(':');
                const date = new Date(Date.UTC(year, month - 1, day, hours, minutes, seconds || 0));
                const unixTimestamp = Math.floor(date.getTime() / 1000);
                updateValues('timestamp', unixTimestamp.toString());
            }
        }

        // --- Event Listeners ---
        hexadecimalInput.addEventListener('input', createIntegerInputHandler('hexadecimal'));
        decimalInput.addEventListener('input', createIntegerInputHandler('decimal'));
        octalInput.addEventListener('input', createIntegerInputHandler('octal'));
        binaryStreamInput.addEventListener('input', createIntegerInputHandler('binary-stream'));
        floatInput.addEventListener('input', (e) => updateValues('floating-point', e.target.value));
        timestampInput.addEventListener('input', createTimestampInputHandler('timestamp'));
        cocoaTimestampInput.addEventListener('input', createTimestampInputHandler('cocoa-timestamp'));
        hfsTimestampInput.addEventListener('input', createTimestampInputHandler('hfs-timestamp'));
        dateInput.addEventListener('input', handleDateTimeChange);
        timeInput.addEventListener('input', handleDateTimeChange);

        signedCheckbox.addEventListener('change', () => updateValues('decimal', decimalInput.value || '0'));
        sizeRadios.forEach(radio => radio.addEventListener('change', (e) => setBitLength(e.target.value, true)));

        // --- Initial Setup ---
        setBitLength(64);
        renderBinaryBits('0');

    </script>
</body>
</html>

