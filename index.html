<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Converter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Fira+Mono&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Simple focus style for better accessibility */
        input:focus {
            box-shadow: 0 0 0 2px #60a5fa; /* blue-400 */
        }
        /* Use monospace for all converter fields */
        input {
            font-family: 'Fira Mono', 'Consolas', 'Menlo', 'Monaco', monospace;
        }
        #binary-bits * {
             font-family: 'Fira Mono', 'Consolas', 'Menlo', 'Monaco', monospace;
        }
        /* Style for date/time pickers */
        input[type="date"], input[type="time"] {
            color-scheme: dark;
        }
    </style>
</head>
<body class="bg-gray-900 flex items-center justify-center min-h-screen py-8">

    <div class="bg-gray-800 p-8 rounded-2xl shadow-2xl w-full max-w-2xl mx-4">
        
        <h1 class="text-3xl font-bold text-center text-white mb-2">Data Converter</h1>
        <p class="text-center text-gray-400 mb-8">Convert between Hexadecimal, Decimal, Binary, Float, and more.</p>

        <div class="grid grid-cols-1 gap-6">
            <!-- Controls -->
            <div class="flex items-center gap-6 mb-2">
                <div class="flex items-center">
                    <input id="signed" type="checkbox" class="mr-2 accent-blue-500 w-5 h-5">
                    <label for="signed" class="text-gray-300 text-sm font-medium select-none cursor-pointer">Signed</label>
                </div>
                <div class="flex items-center gap-4 flex-wrap">
                    <label class="text-gray-300 text-sm font-medium">Size:</label>
                    <label class="flex items-center gap-1 cursor-pointer">
                        <input type="radio" name="size" value="64" class="accent-blue-500">
                        <span class="text-gray-300 text-xs">QWORD</span>
                    </label>
                    <label class="flex items-center gap-1 cursor-pointer">
                        <input type="radio" name="size" value="32" class="accent-blue-500">
                        <span class="text-gray-300 text-xs">DWORD</span>
                    </label>
                    <label class="flex items-center gap-1 cursor-pointer">
                        <input type="radio" name="size" value="16" class="accent-blue-500">
                        <span class="text-gray-300 text-xs">WORD</span>
                    </label>
                    <label class="flex items-center gap-1 cursor-pointer">
                        <input type="radio" name="size" value="8" class="accent-blue-500">
                        <span class="text-gray-300 text-xs">BYTE</span>
                    </label>
                </div>
            </div>
            
            <!-- Integer Inputs -->
            <div class="grid grid-cols-1 gap-6">
                <div>
                    <label for="hexadecimal" class="block mb-2 text-sm font-medium text-gray-300">Hexadecimal</label>
                    <input type="text" id="hexadecimal" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none uppercase" placeholder="e.g., FF">
                </div>
                <div>
                    <label for="hexadecimal-swapped" class="block mb-2 text-sm font-medium text-gray-300">Hexadecimal (byte-swapped)</label>
                    <input type="text" id="hexadecimal-swapped" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none uppercase" placeholder="e.g., FF">
                </div>
                <div>
                    <label for="decimal" class="block mb-2 text-sm font-medium text-gray-300">Decimal</label>
                    <input type="text" id="decimal" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none" placeholder="e.g., 255">
                </div>
                <div>
                    <label for="octal" class="block mb-2 text-sm font-medium text-gray-300">Octal</label>
                    <input type="text" id="octal" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none" placeholder="e.g., 377">
                </div>
                <div>
                    <label for="binary-stream" class="block mb-2 text-sm font-medium text-gray-300">Binary Stream</label>
                    <input type="text" id="binary-stream" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none" placeholder="e.g., 11001010">
                </div>
            </div>
            
            <!-- Interactive Binary Input -->
            <div>
                <label for="binary" class="block mb-2 text-sm font-medium text-gray-300">Binary Bits</label>
                <div id="binary-bits" class="flex flex-col gap-1 mb-2"></div>
                <input type="text" id="binary" class="hidden" autocomplete="off">
            </div>

            <!-- Separator line -->
            <div class="border-t border-gray-700 my-2"></div>

            <!-- Time and Date Inputs -->
            <div class="grid grid-cols-1 gap-6">
                <div id="floating-point-wrapper">
                    <label for="floating-point" class="block mb-2 text-sm font-medium text-gray-300">Floating Point (IEEE 754)</label>
                    <input type="text" id="floating-point" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none disabled:opacity-50" placeholder="Active for 32/64-bit">
                </div>
                <div>
                    <label class="block mb-2 text-sm font-medium text-gray-300">UNIX Time (Epoch: 1970-01-01)</label>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <input type="date" id="unix-date" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none">
                        <input type="time" id="unix-time" step="1" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none">
                    </div>
                </div>
                <div>
                    <label class="block mb-2 text-sm font-medium text-gray-300">Cocoa Core Data Time (Epoch: 2001-01-01)</label>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <input type="date" id="cocoa-date" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none">
                        <input type="time" id="cocoa-time" step="1" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none">
                    </div>
                </div>
                <div>
                    <label class="block mb-2 text-sm font-medium text-gray-300">Mac HFS+ Time (Epoch: 1904-01-01)</label>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <input type="date" id="hfs-date" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none">
                        <input type="time" id="hfs-time" step="1" class="bg-gray-700 border-0 text-white text-lg rounded-lg block w-full p-4 outline-none">
                    </div>
                </div>
            </div>
        </div>

    </div>

    <script>
        // --- DOM Elements ---
        const decimalInput = document.getElementById('decimal');
        const hexadecimalInput = document.getElementById('hexadecimal');
        const hexSwappedInput = document.getElementById('hexadecimal-swapped');
        const binaryInput = document.getElementById('binary');
        const octalInput = document.getElementById('octal');
        const binaryStreamInput = document.getElementById('binary-stream');
        const binaryBitsDiv = document.getElementById('binary-bits');
        const signedCheckbox = document.getElementById('signed');
        const sizeRadios = document.querySelectorAll('input[name="size"]');
        const floatInput = document.getElementById('floating-point');
        
        const unixDate = document.getElementById('unix-date');
        const unixTime = document.getElementById('unix-time');
        const cocoaDate = document.getElementById('cocoa-date');
        const cocoaTime = document.getElementById('cocoa-time');
        const hfsDate = document.getElementById('hfs-date');
        const hfsTime = document.getElementById('hfs-time');

        let isUpdatingDateTime = false;

        // --- State & Constants ---
        let bitLength = 64;
        const COCOA_EPOCH_OFFSET = 978307200n; // Seconds between 1970 and 2001
        const HFS_EPOCH_OFFSET = 2082844800n;   // Seconds between 1904 and 1970

        // --- Helper Functions ---
        const getBitLength = () => bitLength;
        const padBinary = (bin, length = 64) => bin.padStart(length, '0');

        function swapBytes(hexString, bits) {
            if (!hexString) return '';
            const hexLen = bits / 4;
            const paddedHex = hexString.padStart(hexLen, '0');
            const bytes = paddedHex.match(/.{1,2}/g) || [];
            return bytes.reverse().join('');
        }

        function setBitLength(newLength, triggerUpdate = false) {
            bitLength = parseInt(newLength, 10);
            document.querySelector(`input[name="size"][value="${bitLength}"]`).checked = true;
            updateFieldStates();
            if (triggerUpdate) {
                let currentVal = decimalInput.value || '0';
                updateValues('decimal', currentVal);
            }
        }

        function updateFieldStates() {
            const len = getBitLength();
            floatInput.disabled = (len !== 32 && len !== 64);
            if(floatInput.disabled) floatInput.value = '';
        }

        function renderBinaryBits(binStr) {
            binStr = padBinary(binStr, 64);
            binaryBitsDiv.innerHTML = '';
            const activeBitLength = getBitLength();

            for (let line = 0; line < 4; line++) {
                const lineDiv = document.createElement('div');
                lineDiv.className = 'flex gap-4 justify-center items-end';
                for (let group = 0; group < 4; group++) {
                    const groupDiv = document.createElement('div');
                    groupDiv.className = 'flex flex-col items-end';
                    const bitsRow = document.createElement('div');
                    bitsRow.className = 'flex gap-2';
                    for (let b = 0; b < 4; b++) {
                        const bitIdx = line * 16 + group * 4 + b;
                        const bit = binStr[bitIdx];
                        const isActive = (64 - bitIdx) <= activeBitLength;
                        const span = document.createElement('span');
                        span.textContent = bit;
                        span.className = `select-none px-1 py-0.5 rounded text-sm font-bold transition w-6 text-center
                            ${bit === '1' ? 'bg-blue-500 text-white' : 'bg-gray-600 text-gray-200'}
                            ${isActive ? 'cursor-pointer hover:ring-2 hover:ring-blue-400' : 'opacity-40 cursor-not-allowed'}`;
                        if (isActive) {
                            span.addEventListener('click', () => {
                                let bitsArr = binStr.split('');
                                bitsArr[bitIdx] = bitsArr[bitIdx] === '1' ? '0' : '1';
                                let newBin = bitsArr.join('').slice(-activeBitLength);
                                updateValues('binary', newBin);
                            });
                        }
                        bitsRow.appendChild(span);
                    }
                    const lsbIdx = 63 - (line * 16 + group * 4 + 3);
                    const idxLabel = document.createElement('span');
                    idxLabel.textContent = lsbIdx;
                    idxLabel.className = 'block text-xs text-gray-400 w-full text-right mt-0.5';
                    groupDiv.appendChild(bitsRow);
                    groupDiv.appendChild(idxLabel);
                    lineDiv.appendChild(groupDiv);
                }
                binaryBitsDiv.appendChild(lineDiv);
            }
        }
        
        function clearAllInputs(skipId = null) {
            const inputs = [decimalInput, hexadecimalInput, hexSwappedInput, octalInput, binaryStreamInput, floatInput, unixDate, unixTime, cocoaDate, cocoaTime, hfsDate, hfsTime];
            inputs.forEach(input => { if (input.id !== skipId) input.value = ''; });
        }

        function setDateTimePickers(date, datePicker, timePicker) {
            if (isNaN(date.getTime())) {
                datePicker.value = '';
                timePicker.value = '';
                return;
            }
            const year = date.getUTCFullYear();
            const month = (date.getUTCMonth() + 1).toString().padStart(2, '0');
            const day = date.getUTCDate().toString().padStart(2, '0');
            datePicker.value = `${year}-${month}-${day}`;
            
            const hours = date.getUTCHours().toString().padStart(2, '0');
            const minutes = date.getUTCMinutes().toString().padStart(2, '0');
            const seconds = date.getUTCSeconds().toString().padStart(2, '0');
            timePicker.value = `${hours}:${minutes}:${seconds}`;
        }

        // --- Core Conversion Logic ---
        function updateValues(sourceId, sourceValue) {
            if (sourceValue === '' || sourceValue === '-') {
                clearAllInputs(sourceId);
                renderBinaryBits('0');
                return;
            }

            let decimalValue;
            let binStr = '';
            const isSigned = signedCheckbox.checked;
            const len = getBitLength();

            try {
                let normalHex;
                switch (sourceId) {
                    case 'decimal':
                        if (/^-?\d+$/.test(sourceValue)) decimalValue = BigInt(sourceValue);
                        break;
                    case 'hexadecimal-swapped':
                        if (/^[0-9A-Fa-f]*$/.test(sourceValue)) {
                             normalHex = swapBytes(sourceValue, len);
                        }
                        // Fallthrough to hexadecimal case with the un-swapped value
                    case 'hexadecimal':
                        if (/^[0-9A-Fa-f]+$/.test(normalHex || sourceValue)) {
                            let num = BigInt('0x' + (normalHex || sourceValue));
                            decimalValue = isSigned && num >= 2n ** BigInt(len - 1) ? num - 2n ** BigInt(len) : num;
                        }
                        break;
                    case 'binary':
                    case 'binary-stream':
                        if (/^[01]+$/.test(sourceValue)) {
                            let num = BigInt('0b' + padBinary(sourceValue, len).slice(-len));
                            decimalValue = isSigned && sourceValue.padStart(len, '0')[0] === '1' ? num - 2n ** BigInt(len) : num;
                        }
                        break;
                    case 'octal':
                        if (/^[0-7]+$/.test(sourceValue)) {
                            let num = BigInt('0o' + sourceValue);
                            decimalValue = isSigned && num >= 2n ** BigInt(len - 1) ? num - 2n ** BigInt(len) : num;
                        }
                        break;
                    case 'floating-point':
                         if (!isNaN(parseFloat(sourceValue)) && isFinite(sourceValue)) {
                           if (len === 32) {
                                let buf = new ArrayBuffer(4);
                                new DataView(buf).setFloat32(0, parseFloat(sourceValue), false);
                                let u32 = new DataView(buf).getUint32(0, false);
                                decimalValue = isSigned ? BigInt(u32 << 32 >> 32) : BigInt(u32);
                           } else if (len === 64) {
                                let buf = new ArrayBuffer(8);
                                new DataView(buf).setFloat64(0, parseFloat(sourceValue), false);
                                decimalValue = isSigned ? new DataView(buf).getBigInt64(0, false) : new DataView(buf).getBigUint64(0, false);
                           }
                        }
                        break;
                }
            } catch (e) { console.error(e); }

            if (typeof decimalValue !== 'undefined') {
                binStr = (isSigned && decimalValue < 0 ? decimalValue + (2n ** BigInt(len)) : decimalValue).toString(2);
                binStr = padBinary(binStr, 64);
                const activeBinStr = binStr.slice(-len);

                decimalInput.value = decimalValue.toString();
                
                const normalHexValue = BigInt('0b' + activeBinStr).toString(16).toUpperCase();
                if (sourceId !== 'hexadecimal') hexadecimalInput.value = normalHexValue;
                if (sourceId !== 'hexadecimal-swapped') hexSwappedInput.value = swapBytes(normalHexValue, len);

                if (sourceId !== 'octal') octalInput.value = BigInt('0b' + activeBinStr).toString(8);

                const displayBinStr = activeBinStr.replace(/^0+(?!$)/, '') || '0';
                if (sourceId !== 'binary') binaryInput.value = displayBinStr;
                if (sourceId !== 'binary-stream') binaryStreamInput.value = displayBinStr;
                renderBinaryBits(binStr);

                if (len === 32) {
                    let u32 = parseInt(binStr.slice(-32), 2);
                    let buf = new ArrayBuffer(4);
                    new DataView(buf).setUint32(0, u32, false);
                    let f = new DataView(buf).getFloat32(0, false);
                    if (sourceId !== 'floating-point') floatInput.value = isFinite(f) ? f.toString() : 'NaN';
                } else if (len === 64) {
                    let buf = new ArrayBuffer(8);
                    new DataView(buf).setBigUint64(0, BigInt('0b' + binStr), false);
                    let d = new DataView(buf).getFloat64(0, false);
                    if (sourceId !== 'floating-point') floatInput.value = isFinite(d) ? d.toString() : 'NaN';
                } else {
                    if (sourceId !== 'floating-point') floatInput.value = '';
                }

                isUpdatingDateTime = true;
                try {
                    const valForTimestamp = isSigned ? decimalValue : BigInt('0b' + activeBinStr);
                    const unixTimestampMs = Number(valForTimestamp) * 1000;
                    const cocoaTimestampMs = Number(valForTimestamp + COCOA_EPOCH_OFFSET) * 1000;
                    const hfsTimestampMs = Number(valForTimestamp - HFS_EPOCH_OFFSET) * 1000;
                    
                    setDateTimePickers(new Date(unixTimestampMs), unixDate, unixTime);
                    setDateTimePickers(new Date(cocoaTimestampMs), cocoaDate, cocoaTime);
                    setDateTimePickers(new Date(hfsTimestampMs), hfsDate, hfsTime);
                } catch {
                   [unixDate, unixTime, cocoaDate, cocoaTime, hfsDate, hfsTime].forEach(el => el.value = '');
                } finally {
                    setTimeout(() => isUpdatingDateTime = false, 0);
                }
            } else {
                clearAllInputs(sourceId);
            }
        }
        
        // --- Event Listener Helpers ---
        function createDateTimeHandler(dateEl, timeEl, epochOffset = 0n) {
            return () => {
                if (isUpdatingDateTime) return;
                const dateStr = dateEl.value;
                const timeStr = timeEl.value;
                if (dateStr && timeStr) {
                    const utcDate = new Date(`${dateStr}T${timeStr}Z`);
                    const unixTimestamp = BigInt(Math.floor(utcDate.getTime() / 1000));
                    const newDecimalValue = unixTimestamp - epochOffset;
                    updateValues('decimal', newDecimalValue.toString());
                }
            };
        }

        // --- Event Listeners ---
        hexadecimalInput.addEventListener('input', (e) => {
            const input = e.target;
            const originalValue = input.value;
            const cursorPos = input.selectionStart;
            const sanitizedValue = originalValue.replace(/[^0-9a-fA-F]/g, '').toUpperCase();
            if (originalValue !== sanitizedValue) {
                input.value = sanitizedValue;
                const diff = originalValue.length - sanitizedValue.length;
                input.setSelectionRange(cursorPos - diff, cursorPos - diff);
            }
            updateValues('hexadecimal', sanitizedValue);
        });

        hexSwappedInput.addEventListener('input', (e) => {
            const input = e.target;
            const originalValue = input.value;
            const cursorPos = input.selectionStart;
            const sanitizedValue = originalValue.replace(/[^0-9a-fA-F]/g, '').toUpperCase();
            if (originalValue !== sanitizedValue) {
                input.value = sanitizedValue;
                const diff = originalValue.length - sanitizedValue.length;
                input.setSelectionRange(cursorPos - diff, cursorPos - diff);
            }
            updateValues('hexadecimal-swapped', sanitizedValue);
        });

        decimalInput.addEventListener('input', (e) => {
            const input = e.target;
            const originalValue = input.value;
            const cursorPos = input.selectionStart;
            let sanitizedValue = originalValue.replace(/[^-0-9]/g, '');
            if (sanitizedValue.lastIndexOf('-') > 0) {
                sanitizedValue = sanitizedValue.charAt(0) + sanitizedValue.slice(1).replace(/-/g, "");
            }
            if (originalValue !== sanitizedValue) {
                input.value = sanitizedValue;
                const diff = originalValue.length - sanitizedValue.length;
                input.setSelectionRange(cursorPos - diff, cursorPos - diff);
            }
            updateValues('decimal', sanitizedValue);
        });

        octalInput.addEventListener('input', (e) => {
            const input = e.target;
            const originalValue = input.value;
            const cursorPos = input.selectionStart;
            const sanitizedValue = originalValue.replace(/[^0-7]/g, '');
            if (originalValue !== sanitizedValue) {
                input.value = sanitizedValue;
                const diff = originalValue.length - sanitizedValue.length;
                input.setSelectionRange(cursorPos - diff, cursorPos - diff);
            }
            updateValues('octal', sanitizedValue);
        });

        binaryStreamInput.addEventListener('input', (e) => {
            const input = e.target;
            const originalValue = input.value;
            const cursorPos = input.selectionStart;
            const sanitizedValue = originalValue.replace(/[^01]/g, '');
            if (originalValue !== sanitizedValue) {
                input.value = sanitizedValue;
                const diff = originalValue.length - sanitizedValue.length;
                input.setSelectionRange(cursorPos - diff, cursorPos - diff);
            }
            updateValues('binary-stream', sanitizedValue);
        });

        floatInput.addEventListener('input', (e) => {
            const input = e.target;
            const originalValue = input.value;
            const cursorPos = input.selectionStart;
            // Basic filter for invalid characters. Does not prevent all invalid float formats (e.g. "1.2.3").
            const sanitizedValue = originalValue.replace(/[^0-9.eE+-]/g, '');
            if (originalValue !== sanitizedValue) {
                input.value = sanitizedValue;
                const diff = originalValue.length - sanitizedValue.length;
                input.setSelectionRange(cursorPos - diff, cursorPos - diff);
            }
            updateValues('floating-point', sanitizedValue);
        });
        
        const unixHandler = createDateTimeHandler(unixDate, unixTime, 0n);
        unixDate.addEventListener('input', unixHandler);
        unixTime.addEventListener('input', unixHandler);

        const cocoaHandler = createDateTimeHandler(cocoaDate, cocoaTime, COCOA_EPOCH_OFFSET);
        cocoaDate.addEventListener('input', cocoaHandler);
        cocoaTime.addEventListener('input', cocoaHandler);
        
        const hfsHandler = createDateTimeHandler(hfsDate, hfsTime, -HFS_EPOCH_OFFSET);
        hfsDate.addEventListener('input', hfsHandler);
        hfsTime.addEventListener('input', hfsHandler);

        signedCheckbox.addEventListener('change', () => updateValues('decimal', decimalInput.value || '0'));
        sizeRadios.forEach(radio => radio.addEventListener('change', (e) => setBitLength(e.target.value, true)));

        // --- Initial Setup ---
        window.addEventListener('load', () => {
            setBitLength(64);
            clearAllInputs();
            renderBinaryBits('0');
        });

    </script>
</body>
</html>

